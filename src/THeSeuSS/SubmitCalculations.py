'''Submission of FHI-aims and PHONOPY calculations'''

#AUTHOR: Ariadni Boziki

import os
import re
import subprocess
import shutil
import concurrent.futures
import numpy as np
from THeSeuSS import InputsPreparation as inputs
from THeSeuSS import FiniteDisplacements_phonopy as finitedisps
from THeSeuSS import EigenvectorsFrequenciesPHONOPY as eigenfreq
import multiprocessing
from concurrent.futures import ThreadPoolExecutor
from phonopy import Phonopy
from phonopy.interface.calculator import read_crystal_structure, write_crystal_structure, write_supercells_with_displacements, get_default_displacement_distance
from phonopy.file_IO import write_FORCE_SETS, write_FORCE_CONSTANTS
from phonopy.phonon.band_structure import get_band_qpoints_and_path_connections



class PhonopyCalculator:
    
    def __init__(self, code: str, cell_dims: str, output_file_of_SCFSs: str):
        
        self.code = code
        self.cell_dims = cell_dims
        self.output_file_of_SCFSs = output_file_of_SCFSs
        self.path = os.getcwd()
        self.conts = []
        self.forces = None
        self.dataset = None
        self.dynamical_matrix = None
        self.eigvecs = None
        self.eigvals = None
        self.freq = None
        self.geometry_processor = None
        self.no_of_atoms = None
        self.forces_path = None
        self._setup_geometry_processor()

    def _read_crystal_structure(self):
        """
        Reads the crystal structure file based on the specified code.
        """

        if self.code == 'aims':
            return read_crystal_structure('vibrations/geometry.in', interface_mode='aims')
        elif self.code == 'dftb+':
            return read_crystal_structure('vibrations/geo.gen', interface_mode='dftbp')

    def _setup_phonopy(self):
        """
        Sets up Phonopy for phonon calculations.
        Reads the crystal structure and extracts the unit cell and optional structure info. 
        Initializes a Phonopy object with the unit cell and supercell matrix. 
        Generates atomic displacements using default distances specific to the code.
        """

        unitcell, optional_structure_info = self._read_crystal_structure()
        cell_dims_int = [int(num) for num in self.cell_dims.split()]
        supercell_matrix = [[cell_dims_int[0], 0, 0], [0, cell_dims_int[1], 0], [0, 0, cell_dims_int[2]]]
        self.phonon = Phonopy(unitcell,supercell_matrix)
        default_displacement_for_code = get_default_displacement_distance(interface_mode=self.code)
        self.phonon.generate_displacements(distance=default_displacement_for_code)
        self.disps = self.phonon.displacements

    def supercell_disp_PHONOPY(self):
        """
        Retrieves the supercells with atomic displacements generated by Phonopy and the supercell. 
        Writes the supercells with displacements to output files based on the code.
        """

        self._setup_phonopy()
        os.chdir('vibrations')
        supercells = self.phonon.supercells_with_displacements
        gen_supercell = self.phonon.supercell
        if self.code == 'aims':
            write_supercells_with_displacements('aims', gen_supercell, supercells)
        elif self.code == 'dftb+':
            write_supercells_with_displacements('dftbp', gen_supercell, supercells)
        os.chdir('../')

    def submit_phonopy_displacements(self):
        """
        Generate structures with displacements using PHONOPY. If successful, it prints a confirmation message. 
        If an error occurs it prints an error message.
        """

        try:
            self.supercell_disp_PHONOPY()
            print(f'PHONOPY GENERATED THE STRUCTURES WITH THE DISPLACEMENTS\n')
            print('*' * 150) 

        except Exception as e:
            print(f'GENERATION OF THE STRUCTURES WITH THE DISPLACEMENTS BY PHONOPY / AN ERROR WAS OCCURED: {e}')
            print('*' * 150) 

    def _setup_geometry_processor(self):
        """
        Calculates the number of atoms in the supercell based on the code, by initializing GeometryProcessor object.
        """

        if self.code == 'aims':
            new_path = os.path.join(self.path, 'vibrations', 'geometry.in.supercell')
            geom_input = new_path
        elif self.code == 'dftb+':
            new_path = os.path.join(self.path, 'vibrations', 'geo.genS')
            geom_input = new_path

        self.geometry_processor = inputs.GeometryProcessor(geom_input, self.code)

    def _number_of_atoms(self)-> int:
        """
        Returns the number of atoms in the supercell based on the code. Used for both periodic and non periodic systems.
        """

        return self.geometry_processor.number_of_atoms()

    def _get_coordinates(self)-> list:
        """
        Returns the coordinates of the supercell based on the code. Used for both periodic and non periodic systems.
        """

        return self.geometry_processor.read_coordinates()

    def read_forces_from_output(self, output_path: str):
        """
        Extracts the forces from the FHIaims output and results.tag DFTB+ file.
        """

        self.no_of_atoms = self._number_of_atoms()

        if self.code == 'aims':
            forces_identifier = 'Total atomic forces (unitary forces cleaned)'
        elif self.code == 'dftb+':
            forces_identifier = 'forces'

        f=open(output_path, 'r')
        found_unique_line = False

        forces_lines = []
        for line in f:
            if forces_identifier in line:
                found_unique_line = True
                continue

            if found_unique_line:
                forces_lines.append(line.strip())
                if len(forces_lines) >= self.no_of_atoms:
                    break

        pattern = r"[-+]?\d+\.\d+E[-+]?\d+"

        self.forces = []

        for item in forces_lines:
            numbers = re.findall(pattern, item)
            if len(numbers) >= 3:
                last_three_columns = [float(num) for num in numbers[-3:]]
                self.forces.append(last_three_columns)

        return self.forces

    def sort_directories(self)-> list:
        """
        Sorts directories in the current directory that contain the substring 'Coord', 
        based on the numeric value in their names.
        """

        new_path = os.path.join(self.path, 'vibrations')
        contents = [item for item in os.listdir(new_path) if os.path.isdir(os.path.join(new_path, item))]
        for ii in contents:
            if 'Coord' in ii:
                self.conts.append(ii)
        self.conts.sort(key=lambda f: int(''.join(filter(str.isdigit, f))))
    
        return self.conts

    def force_identifier(self, drct: str)-> str: 
        """
        Constructs the path to the output file containing forces for a specific calculation.
        """

        if self.code == 'aims':
            self.forces_path = os.path.join(self.path, 'vibrations', drct, self.output_file_of_SCFSs)
        elif self.code == 'dftb+':
            self.forces_path = os.path.join(self.path, 'vibrations', drct, 'results.tag')

        return self.forces_path

    def disp_forces_dataset_dyn_matrix(self):
        """
        Generates a dataset for producing the force constants and calculating the dynamical matrix 
        based on displacements and forces obtained from FHIaims or DFTB+ output files.
        """

        self.no_of_atoms = self._number_of_atoms()
        self.dataset = {'natom': self.no_of_atoms,
                'first_atoms': []}

        self._setup_phonopy()
        self.conts = self.sort_directories()
        for j, jj in zip(self.disps,self.conts):

            self.forces_path = self.force_identifier(jj)
            self.forces = self.read_forces_from_output(self.forces_path)
            entry = {
                    'number': np.array([j[0]]),
                    'displacement': np.array(j[1:]),
                    'forces': np.array(self.forces)
            }
            self.dataset['first_atoms'].append(entry)

        self.phonon.dataset = self.dataset
        self.phonon.produce_force_constants()

        q = [0.0,0.0,0.0]
        self.dynamical_matrix = self.phonon.get_dynamical_matrix_at_q(q)

        return self.dynamical_matrix

    def plot_band_structure(self):
        """
        Plots the band structure using predefined paths in reciprocal space.
        Uses Phonopy to calculate and visualize the band structure.
        """

        path = [[[0, 0, 0], [0, 0.5, 0], [0, 0.5, 0.5]],
                [[0, 0, 0.5], [0, 0, 0], [-0.5, 0, 0.5], [-0.5, 0.5, 0.5]],
                [[0, 0.5, 0], [-0.5, 0.5, 0], [-0.5, 0, 0], [0, 0, 0]]]
        labels = ["$\\Gamma$", "Z", "D", "B", "$\\Gamma$", "A", "E", "Z", "$C_{2}$", "$Y_{2}$", "$\\Gamma$"]
        qpoints, connections = get_band_qpoints_and_path_connections(path, npoints=51)
        self.phonon.run_band_structure(qpoints, path_connections=connections, labels=labels)
        self.phonon.plot_band_structure().savefig("phonon_band_structure.pdf")
        self.phonon.write_yaml_band_structure()
        band_dict = self.phonon.get_band_structure_dict()



class Calculator:

    def __init__(self, code: str, output_file: str, dispersion: bool, functional: str = None, commands: str = None):

        self.code = code
        self.commands = commands
        self.output_file = output_file
        self.functional = functional
        self.dispersion = dispersion

    def submit_job(self):
        """
        Submission of electronic structure calculations, (FHIaims and DFTB+).
        """

        number_of_cores = os.environ.get('number_of_cores')
        if number_of_cores is not None:
            number_of_cores = int(number_of_cores)
            num_threads = max(1, number_of_cores)  # Adjust the number of threads as needed
            print(f'NUMBER OF CORES ALLOCATED FOR GEOMETRY OPTIMIZATION: {num_threads}')

            parts = self.commands.split(';')
            first_part = ";".join(parts[:-1]).strip()
            last_part = parts[-1].strip()
        else:
            num_threads = multiprocessing.cpu_count()
            print(f'NUMBER OF CORES: {num_threads}')

        if number_of_cores is not None:
            if ";" not in self.commands: 
                command_tmp = f'srun --cpus-per-task 1 --ntasks {num_threads} {last_part}'
            else:
                command_tmp = f'{first_part}; srun --cpus-per-task 1 --ntasks {num_threads} {last_part}'
        else:
            command_tmp = self.commands
        
        subprocess.run(command_tmp, shell=True, executable='/bin/bash')

    def frozen_phonon_approximation_drct(self):
        """
        Creates a directory to store files associated with the frozen phonon approximation.
        """

        new_geometry_flag = False
        if (self.code == 'aims'):
            geometry = 'geometry.in'
            new_geometry = 'geometry.in.next_step'
        elif (self.code == 'dftb+'):
            geometry = 'geo.gen'
            new_geometry = f'{self.output_file}.gen'

        path = os.getcwd()
        os.mkdir('vibrations')
        output_path = os.path.join(path, 'vibrations')
        path_new_geom_input = os.path.join(path, new_geometry)

        if os.path.isfile(path_new_geom_input):
            geometry_path = os.path.join(path, new_geometry)
            new_geometry_flag = True
        else:
            geometry_path = os.path.join(path, geometry)
        shutil.copy(geometry_path, output_path)  

        if new_geometry_flag:
            geometry_path_rename = os.path.join(output_path, geometry)
            os.rename(geometry_path, geometry_path_rename) 

    def run_command(self, command: str)-> str:
        """
        Executes the given command in the shell environment and returns the output.
        """

        try:
            # Run the command and capture its output
            result = subprocess.run(command, shell=True, capture_output=True, text=True, check=True)
            # Process the result as needed
            return result.stdout
        except subprocess.CalledProcessError as e:
            # Handle command failure
            return f"Error running {command}: {e}"

    def submit_jobs_in_parallel(self):
        """
        Submits multiple jobs in parallel using a ThreadPoolExecutor.
        Note: Adjust the number of threads based on the available computational resources and the number of folders.
        """

        command_statement = []

        path = os.getcwd()
        new_path = os.path.join(path, 'vibrations')
        contents = [item for item in os.listdir(new_path) if os.path.isdir(os.path.join(new_path, item))]
        conts = []
        for ii in contents:
            if 'Coord' in ii:
                conts.append(ii)
        conts.sort(key=lambda f: int(''.join(filter(str.isdigit, f))))

        number_of_cores = os.environ.get('number_of_cores')
        if number_of_cores is not None:
            number_of_cores = int(number_of_cores)
            no_of_folders = len(conts)
            num_threads = max(1, int(number_of_cores/no_of_folders))  # Adjust the number of threads as needed
            print(f'NUMBER OF CORES ALLOCATED PER SINGLE POINT CALCULATION ASSOCIATED TO FINITE DIFFERENCE METHOD: {num_threads}')

            parts = self.commands.split(';')
            first_part = ";".join(parts[:-1]).strip()
            last_part = parts[-1].strip()
        else:
            num_threads = multiprocessing.cpu_count()
            print(f'NUMBER OF CORES: {num_threads}')

        for i in conts:
            if number_of_cores is not None:
                if ";" not in self.commands: 
                    command_tmp = f'cd vibrations; cd {i}; srun --cpus-per-task 1 --ntasks {num_threads} {last_part}'
                else:
                    command_tmp = f'cd vibrations; cd {i}; {first_part}; srun --cpus-per-task 1 --ntasks {num_threads} {last_part}'
            else:
                command_tmp = f'cd vibrations; cd {i}; {self.commands}'
            command_statement.append(command_tmp)

            if self.code == 'aims' and self.functional not in ['pbe', 'lda']:
                if number_of_cores is not None:
                    command_tmp = f'cd vibrations; cd {i}; cd polarizability; {first_part}; srun --cpus-per-task 1 --ntasks {num_threads} {last_part}'
                else:
                    command_tmp = f'cd vibrations; cd {i}; cd polarizability; {self.commands}'
                command_statement.append(command_tmp)

            if self.dispersion and self.code == 'dftb+':
                if number_of_cores is not None:
                    command_tmp = f'cd vibrations; cd {i}; cd polarizability; srun --cpus-per-task 1 --ntasks {num_threads} {last_part}'
                else:
                    command_tmp = f'cd vibrations; cd {i}; cd polarizability; {self.commands}'
                command_statement.append(command_tmp)

        with ThreadPoolExecutor(max_workers=num_threads) as executor:
            executor.map(self.run_command, command_statement)
